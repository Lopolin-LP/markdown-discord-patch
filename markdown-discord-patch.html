<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Discord Patch</title>
    <style>
        :root {
            --text: #fff;
            --back: #000;
            --grey: #7f7f7f;
            --back-red: #200;
            --textarea-size: calc(100% - 2em);
        }
        html {
            background-color: var(--back);
            color: var(--text);
            font-family: Arial, Helvetica, sans-serif;
        }
        form h2 {
            border-top: solid var(--grey) 0.1em;
            padding-top: 0.5em;
            width: max-content;
        }
        small ul {
            margin: 0;
        }
        a {
            color: var(--text);
        }
        a:hover {
            color: var(--text);
        }
        a:active {
            color: var(--text);
        }
        a:visited {
            color: var(--text);
        }
        /* .radio input[type="radio"], .radio input[type="checkbox"], .radio select, .radio input[type="number"] { */
        .radio input, .radio select {
            margin: 0 0.5em;
        } 
        .radio input[type="radio"], .radio input[type="checkbox"] {
            width: 2em;
            height: 2em;
            transform-origin: left;
        }
        .radio input:first-child, select:first-child {
            margin: 0;
            margin-right: 0.5em;
        }
        .radio input:last-child, select:last-child {
            margin: 0;
            margin-left: 0.5em;
        }
        .radio {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-bottom: 0.5em;
        }
        .radio:last-child:not(.radio-nl) { /* nl: not last/new lines */
            margin-bottom: 0;
        }
        textarea {
            background-color: var(--back);
            color: var(--text);
            border: solid var(--grey) 0.5em;
            border-radius: 1em;
            padding: 0.5em;
            resize: vertical;
        }
        #textareainput {
            width: var(--textarea-size);
            height: 6em;
        }
        #theContainer {
            display: grid;
            grid-template-columns: 50% 50%;
        }
        #result textarea {
            width: var(--textarea-size);
            height: 30vh;
            overflow-y: visible;
        }
        .defaultHidden {
            display: none;
        }
        .defaultHidden[data-active] {
            display: inherit;
        }
        #version {
            position: fixed;
            top: 2em;
            right: 2em;
            font-size: small;
        }
        .alpha {
            color: #a00;
        }
        .beta {
            color: #aa0;
        }
        .experimental {
            color: #07f;
        }
    </style>
    <script>
        window.onload = function() {
            const lclsWarn = "option couldn't be loaded. They may not exist within localStorage."
            try {
                let whatmd = localStorage.getItem("mddcp-md");
                document.querySelector('input[name="marktab"]').checked = false;
                switch (whatmd) {
                    case "none":
                        document.getElementById("mark-none").checked = true;
                        break;
                    case "tab":
                        document.getElementById("mark-tab").checked = true;
                        break;
                    case "space":
                        document.getElementById("mark-space").checked = true;
                        break;
                
                    default:
                        break;
                    }
                markSpaceExtra();
            } catch(err) {
                console.warn("Markdown", lclsWarn);
                console.err(err);
            }
            try {
                let whatnr = localStorage.getItem("mddcp-nr");
                if (whatnr == '') {
                    whatnr = 4; /* set the default */
                }
                document.getElementById("mark-amount").value = Number(whatnr);
            } catch(err) {
                console.warn("Space Number", lclsWarn);
                console.err(err);
            }
            try {
                let whatmsg = localStorage.getItem("mddcp-2k");
                if (whatmsg === "") {
                    whatmsg = "disabled";
                }
                document.getElementById("splitmsg").value = whatmsg;
                splitMessagesExtra();
            } catch(err) {
                console.warn("Split Message", lclsWarn);
                console.error(err);
            }
            try {
                let whatlnb = localStorage.getItem("mddcp-ll");
                document.getElementById("splitmsg-ll").checked = JSON.parse(whatlnb);
                lastLinesExtra();
            } catch(err) {
                console.warn("Last Lines Checkbox", lclsWarn);
                console.error(err);
            }
            try {
                let whatlnbs = localStorage.getItem("mddcp-llstr");
                document.getElementById("splitmsg-llstr").value = whatlnbs;
            } catch(err) {
                console.warn("Last Lines String", lclsWarn);
                console.error(err);
            }
            try {
                let whatlnbs = localStorage.getItem("mddcp-cl");
                document.getElementById("charlimit").value = whatlnbs;
            } catch(err) {
                console.warn("Character Limit", lclsWarn);
                console.error(err);
            }
        }
        let placeholderStillThere = true;
        function execute(elm) {
            const splitmsg = document.querySelector("#splitmsg").value;
            const marktab = document.querySelector('input[name="marktab"]:checked').value;
            let amount = undefined;
            const text = document.querySelector("textarea").value;
            if (marktab === "space") {
                let amount_elm = document.querySelector('#mark-amount').value;
                if (amount_elm === "") {
                    amount = 4; /* Set default if no value given */
                    return;
                }
                amount = Number(amount_elm);
            }
            /* Debugging */ console.log(splitmsg, marktab, amount, text);
            let regex = undefined;
            let spacesString = undefined;
            let replacestring = "  "; // The amount of spaces to replace it with
            let replacedtext = undefined;
            switch (marktab) {
                case "tab":
                    regex = new RegExp(`^(\t)*`, "gm");
                    spacesString = "\t";
                    break;
                case "space":
                    regex = new RegExp(`^(${" ".repeat(amount)})*`, "gm");
                    spacesString = " ".repeat(amount);
                    break;
            
                default:
                    break;
            }
            if (marktab !== "none") {
                replacedtext = text.replace(regex, function(match) {
                    return match.split(spacesString).join(replacestring);
                });
            } else {
                replacedtext = text; // some only want to split messages, how depressing...
            }
            let messages = [replacedtext];
            if (splitmsg == "smart") {
                messages = splitMessage2(replacedtext);
            } else if (splitmsg == "simple") {
                messages = splitMessage(replacedtext);
            }
            if (document.getElementById("textareainput").value !== "") {
                let oldAreas = document.querySelectorAll("#result textarea");
                oldAreas.forEach(element => {
                    element.remove();
                });
                for (let i = 0; i < messages.length; i++) {
                    const element = messages[i];
                    createResult(element, splitmsg);
                }
            }
            if (document.getElementById("textareainput").value === messages[0] && document.getElementById("textareainput").value !== "") {
                let oldAreas = document.querySelectorAll("#result textarea");
                oldAreas.forEach(element => {
                    element.remove();
                });
                let mockingTheUser = [
                    "this ain't a repeater",
                    "bro made something comparible to translating english to english",
                    "reall?",
                    "if (output === input) {mockUser();}",
                    "why",
                    "*mocks you*",
                    "*sames you*"
                    /* "To GeT tHe ReSuLt, ClIcK tHiS lInK!!!11!: <a href='https://www.youtube.com/watch?v=dQw4w9WgXcQ' target='blank'>hot uwu girl</a>"*/
                ];
                let div = document.createElement("div");
                div.innerHTML = `<textarea data-no-result disabled style="text-align: center;color: var(--text); background-color: var(--back-red);">${mockingTheUser[Math.floor(Math.random() * mockingTheUser.length)] + " &#128128;"}</textarea>`;
                document.getElementById("result").appendChild(div.querySelector("textarea"));
            }
            console.log('"'+regex+'"', '"'+replacestring+'"');
        }
        function splitMessage(text) { /* legacy splitMessage + newly added customizable char_limit */
            let textarrs = [];
            let currentText = text;
            let char_limit = 2000;
            if (document.getElementById("charlimit").value !== "") {
                /* set custom character limit */
                char_limit = document.getElementById("charlimit").value;
            }
            for (let i = 0; i < Math.ceil(text.length/char_limit); i++) {
                textarrs.push(currentText.substring(0, char_limit))
                currentText = currentText.substring(char_limit);
            }
            return textarrs;
        };
        function splitMessage2(text) { // A more optimized approach
            // return: [array, with, all, splits]
            // returned by while(){} loop: ["output", "prepend to currentText"]
            let textarrs = [];
            let currentText = text;
            let char_limit = 2000;
            if (document.getElementById("charlimit").value !== "") {
                /* set custom character limit */
                char_limit = document.getElementById("charlimit").value;
            }
            let previousCurrentText = "";
            let keepEmptyLineString = "_ _";
            if (document.getElementById("splitmsg-llstr").value !== "") {
                /* custom force empty lines */
                keepEmptyLineString = document.getElementById("splitmsg-llstr").value;
            }
            const shouldKeepEmptyLine = document.getElementById("splitmsg-ll").checked;
            function nLineFix(substring, leftover) { /* only execute within while loop and after optimal slice was finished. */
                return [substring, leftover];
            }
            while (currentText !== "") {
                previousCurrentText = currentText;
                // apply 2k limit
                // split into char_limit_text and currentText
                let char_limit_text = currentText.substring(0, char_limit);
                currentText = currentText.substring(char_limit);
                // search for optimal position to cut instead of 2k.
                // lastOptimalSlice: The position of the most optimal to use substring against. NOTE: USE SUBSTRING, AS IT MAY RETURN -1.
                // usedSlice: string that contains the slice used.
                // noSlice: no slice is able to be used
                lastOptimalSlice = char_limit_text.lastIndexOf("\n");
                let usedSlice = "\n";
                let noSlice = false;
                if (lastOptimalSlice === -1) {
                    lastOptimalSlice = char_limit_text.lastIndexOf(" ");
                    usedSlice = " ";
                    if (lastOptimalSlice === -1) {
                        noSlice = true;
                    }
                }
                /* DEBUGGING */ console.log("SLICING METHOD:", JSON.stringify(usedSlice), "NoSlice:", noSlice);
                if (noSlice === true) {
                    textarrs.push(char_limit_text);
                } else if (currentText !== "") {
                    // slice the text
                    // substring: the first most optimized half
                    // leftover: the left over beteween substring and currentText
                    let substring = char_limit_text.substring(0, lastOptimalSlice);
                    let leftover = char_limit_text.substring(lastOptimalSlice + usedSlice.length);
                    // add keepEmptyLineString
                    console.log("Optimized Strings:", JSON.stringify(substring), JSON.stringify(leftover))
                    if (substring.endsWith("\n") && shouldKeepEmptyLine === true) {
                        /* DEBUGGING */ console.log("It ended with \\n!")
                        if (lastOptimalSlice < char_limit - keepEmptyLineString.length) {
                            /* if under limit */
                            substring += keepEmptyLineString;
                            /* DEBUGGING */ console.log("It's under the limit. keepEmptyLineString simply appended.")
                        } else if (lastOptimalSlice > char_limit - keepEmptyLineString.length) {
                            /* if inbetween limit and unaddable without going over the limit */
                            let counter = 0;
                            while (substring.endsWith("\n")) {
                                substring = substring.slice(0, -1);
                                counter++;
                            }
                            leftover = keepEmptyLineString + "\n".repeat(counter) + leftover;
                            /* DEBUGGING */ console.log("The Inbetween length was detected, keepEmptyLineString counter:", counter);
                        } else {
                            /* DEBUGGING */ console.log("...but nothing got executed.");
                        };
                    };
                    // re-add leftover to currentText and add substring to textarrs
                    currentText = leftover + currentText;
                    textarrs.push(substring);
                } else if (currentText === "") {
                    // add keepEmptyLineString
                    if (char_limit_text.endsWith("\n") && shouldKeepEmptyLine === true) {
                        char_limit_text += keepEmptyLineString;
                    }
                    // simply push it.
                    textarrs.push(char_limit_text);
                    console.log("Last currentText finished!");
                }
                // check if it was the same text again, if it wasn't you aren't fucked
                if (previousCurrentText === currentText) {
                    let aWarning = document.createElement("h3");
                    aWarning.innerText = `The Last Entry in the result may be over ${char_limit} characters long, as the last sliced and optimized text was the exact same as before. If we would've continued, your browser might've crashed!`;
                    aWarning.style.color = "#f00";
                    document.querySelector("#result h2").appendChild(aWarning);
                    break;
                }
                // debugging tools
                // console.log("THIS IS THE SUBSTRING\n\n"+ substring)
                // console.log("THIS IS THE LEFTOVER\n\n"+ leftover);
                // console.log("THIS IS EVERYTHING ELSE", lastOptimalSlice, usedSlice);
                // if (usedSlice===" ") {
                //     console.log("space slice used")
                // }
            }
            /* DEBUGGING */ console.log("FINAL ARGS", textarrs, JSON.stringify(currentText), char_limit, JSON.stringify(previousCurrentText), JSON.stringify(keepEmptyLineString));
            return textarrs;
        };
        function createResult(text, resize) {
            let area51 = document.createElement("textarea");
            area51.disabled = true;
            area51.value = text;
            document.getElementById("result").appendChild(area51);
            if (resize === false) {
                let newestChild = document.querySelector("#result *:last-child");
                newestChild.style.height = (newestChild.scrollHeight) + "px";
                newestChild.style.resize = "none";
            }
        }
        /* enable specific settings if certain things happen... */
        function markSpaceExtra() {
            let state = document.querySelector('input[name="marktab"]:checked').value;
            let div = document.getElementById("mark-space-extra");
            if (state == "space") {
                div.setAttribute("data-active", "");
                document.getElementById("mark-amount").setAttribute("required", ""); /* enforce them to say something, but also do not force them if it's not chosen */
            } else {
                try {
                    div.removeAttribute("data-active");
                } catch {}
                try {
                    document.getElementById("mark-amount").removeAttribute("required");
                } catch {}
            }
            console.log("mark-space-extra: State Changed to", state);
        }
        function splitMessagesExtra() {
            let state = document.getElementById("splitmsg").value;
            let div = document.getElementById("splitsmsg-extra");
            let div2 = document.getElementById("charlimit-parent");
            if (state == "smart") {
                div.setAttribute("data-active", "");
            } else {
                try {
                    div.removeAttribute("data-active");
                } catch {}
            }
            if (state == "disabled") {
                try {
                    div2.removeAttribute("data-active");
                } catch {}
            } else {
                div2.setAttribute("data-active", "");
            }
            console.log("split-messages-extra: State Changed to", state);
        }
        function lastLinesExtra() {
            let state = document.getElementById("splitmsg-ll").checked;
            let div = document.getElementById("splitmsg-llstr-parent");
            if (state === true) {
                div.setAttribute("data-active", "");
            } else {
                try {
                    div.removeAttribute("data-active");
                } catch {}
            }
            console.log("splitmsg-llstr-extra: State Changed to", state);
        }
        function preventEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
            }
        }
        function fixNumUser(elm) {
            if (elm.value == "") {
                return;
            }
            if (elm.value != "" && elm.value < 1) {
                elm.value = 1;
            }
            elm.value = Math.floor(elm.value);
        }
        function resetSettings() {
            try {
                localStorage.removeItem("mddcp-md");
            } catch {}
            try {
                localStorage.removeItem("mddcp-nr");
            } catch {}
            try {
                localStorage.removeItem("mddcp-2k");
            } catch {}
            try {
                localStorage.removeItem("mddcp-ll");
            } catch {}
            try {
                localStorage.removeItem("mddcp-llstr");
            } catch {}
            try {
                localStorage.removeItem("mddcp-cl");
            } catch {}
            localStorage.setItem("mddcp-rt", "");
            window.location.reload();
        }
        window.onbeforeunload = function() {
            if (typeof localStorage.getItem("mddcp-rt") === "string") {
                /* Reset Settings */
                console.log("Prevent saving of Settings due to reset!");
            } else {
                /* Save Settings */
                localStorage.setItem("mddcp-md", document.querySelector('input[name="marktab"]:checked').value);
                localStorage.setItem("mddcp-nr", document.getElementById("mark-amount").value);
                localStorage.setItem("mddcp-2k", document.getElementById("splitmsg").value);
                localStorage.setItem("mddcp-ll", document.getElementById("splitmsg-ll").checked);
                localStorage.setItem("mddcp-llstr", document.getElementById("splitmsg-llstr").value);
                localStorage.setItem("mddcp-cl", document.getElementById("charlimit").value);
            }
            try {
                /* Remove resetting again */
                localStorage.removeItem("mddcp-rt");
            } catch {}
        }
    </script>
</head>
<body>
    <h1>Discord Markdown Patch / Split Messages</h1>
    <div id="version">v0.3</div>
    <p>
        A very lightweight tool to fix discords markdown shitty Indention detection. Available for free on
        <a href="https://github.com/Lopolin-LP/markdown-discord-patch" target="_blank">GitHub</a>.
        <a href="https://raw.githubusercontent.com/Lopolin-LP/markdown-discord-patch/main/LICENSE" target="_blank">Licensed under GPLv3.</a>
    </p>
    <ul style="color:red">
        <p>Things Left to be added until v1.0:</p>
        <li>Finalise mocking</li>
    </ul>
    <noscript style="color: red;">
        <h1><h1>You need JavaScript enabled for this website to work!</h1><br>Click <a href="https://www.enable-javascript.com/" target="_blank">HERE</a> to learn more.</h1>
    </noscript>
    <div id="theContainer">
        <form action="javascript:;" onsubmit="execute(this)">
            <!-- Markdown -->
            <div onclick="markSpaceExtra();"> <!-- why there no onchange for div? :( -->
                <h2>Markdown Indention Patch</h2>
                <div class="radio">
                    <input type="radio" id="mark-none" name="marktab" value="none">
                    <label for="mark-none">None</label>
                </div>
                <div class="radio">
                    <input type="radio" id="mark-tab" name="marktab" value="tab" checked="checked">
                    <label for="mark-tab">Fix Markdown (TAB)</label>
                </div>
                <div class="radio">
                    <input type="radio" id="mark-space" name="marktab" value="space">
                    <label for="mark-space">Fix Markdown (Space) <i>(Extra Options)</i></label>
                </div>
            </div>
            <!-- Extra Options -->
            <h2>Extra Options</h2>
            <div id="mark-space-extra" class="radio defaultHidden">
                <label for="mark-amount">Amount of Spaces per indent (Number)</label>
                <input type="number" name="mark-amount" id="mark-amount" min="1" value="4" placeholder="4" onkeyup="fixNumUser(this);">
            </div>
            <!-- Split Messages -->
            <div class="radio">
                <select id="splitmsg" onclick="splitMessagesExtra();">
                    <option value="disabled">Disabled</option>
                    <option value="simple">Simple</option>
                    <option value="smart">Smart (Recommended)</option>
                </select>
                <label for="splitmsg">Split Messages<sup>1</sup></label>
            </div>
            <div id="splitsmsg-extra" class="defaultHidden">
                <!-- Last Lines -->
                <div class="radio" onclick="lastLinesExtra();">
                    <input type="checkbox" class="radio-nl" name="splitmsg-ll" id="splitmsg-ll">
                    <label for="splitmsg-ll">Force Line Breaks at end of message to appear in Discord<sup>2</sup></label>
                </div>
                <!-- Last Lines: String -->
                <div class="radio radio-nl defaultHidden" id="splitmsg-llstr-parent">
                    <input type="text" name="splitmsg-llstr" id="splitmsg-llstr" placeholder="_ _">
                    <label for="splitmsg-llstr">Forced Line Breaks String<sup>3</sup></label>    
                </div>
            </div>
            <!-- Custom Character Limit -->
            <div id="charlimit-parent" class="defaultHidden">
                <div class="radio">
                    <input type="number" name="charlimit" id="charlimit" list="commonCharacterLimits" min="1" placeholder="2000" onkeyup="fixNumUser(this);">
                    <label for="charlimit">Charater Limit<sup>4</sup></label>    
                </div>
                <datalist id="commonCharacterLimits">
                    <option value="2000">Discord Free</option>
                    <option value="280">Twitter Free</option>
                    <option value="4000">Discord Nitro / Twitter Blue</option>
                </datalist>
            </div>
            <!-- Text Input -->
            <br>
            <h2>Text Input</h2>
            <textarea id="textareainput"></textarea>
            <!-- Submit -->
            <br>
            <h2>Submit and Other</h2>
            <input type="submit" value="Submit" id="submit-input" style="font-size: 2em;">
            <br><br>
            <input type="button" onclick="resetSettings();" value="Reset Options to Default (Reloads Webpage)" id="reset-input">
            <small>
                <br><br>
                <sup>1 </sup>Modes:<ul>
                    <li><b>Disabled:</b> No Split Messages</li>
                    <li><b>Simple:</b> Cuts everything EXACTLY after the character limit. Very Lightweight.</li>
                    <li><b>Smart (Recommended):</b> Tries to hide that these are multiple messages by cutting after line breaks, forcing new lines or cutting after a word. It's fully customizable. Only breaks when you really try to break it.</li>
                </ul>
                <sup>2 </sup>If an empty line is found at the very end of a message, it will force discord to make it appear<br>
                <sup>3 </sup>The String that gets appended to detected empty lines at end/beginning of messages is "_ _". With this you can change it. This string works because Discord cannot remove the whitespace at the end of message, because there is a "_", and Discord doesn't remove whitespace or empty lines inside messages.
                The reason for the other "_" is to make sure the other one disappears. It was chosen to use "_ _" over "** **" due to character amount, tho it doesn't matter in most cases.<br>
                <sup>4 </sup>After how many characters the message must be cut. A few presets are available. Create an issue on GitHub if you have suggestions.
            </small>
        </form>
        <div id="result">
            <h2>Result</h2>
            <textarea data-no-result disabled style="text-align: center;color: var(--text); background-color: var(--back-red);">There is not Result yet!</textarea>
        </div>
    </div>
    <br><br>
    <script>
        allInputs = document.querySelectorAll("input");
        for (let i = 0; i < allInputs.length; i++) {
            const element = allInputs[i];
            element.addEventListener("keypress", ()=>{preventEnter(event)});
        }
        enterEventSpecial = {
            splitmsg: document.getElementById("splitmsg"),
            submit: document.getElementById("submit-input")
        }
        enterEventSpecial.splitmsg.removeEventListener("keypress", ()=>{preventEnter(event)});
        enterEventSpecial.splitmsg.addEventListener("keypress", function (event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                this.checked = !this.checked;
            }
        });
        enterEventSpecial.submit.removeEventListener("keypress", ()=>{preventEnter(event)});
        enterEventSpecial.submit.addEventListener("keypress", function (event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                enterEventSpecial.submit.click();
            }
        });
    </script>
</body>
</html>
