<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="data:image/png;base64,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">
    <title>Markdown Discord Patch</title>
    <style>
        :root {
            --text: #fff;
            --back: #000;
            --grey: #7f7f7f;
            --back-red: #200;
            --textarea-size: calc(100% - 2em);
        }
        html {
            background-color: var(--back);
            color: var(--text);
            font-family: Arial, Helvetica, sans-serif;
        }
        form h2 {
            border-top: solid var(--grey) 0.1em;
            padding-top: 0.5em;
            width: max-content;
        }
        small ul {
            margin: 0;
        }
        a {
            color: var(--text);
        }
        a:hover {
            color: var(--text);
        }
        a:active {
            color: var(--text);
        }
        a:visited {
            color: var(--text);
        }
        ::-webkit-resizer {
            --border-col: 2px solid black;
            border-bottom: var(--border-col);
            border-right: var(--border-col);
            background: linear-gradient(135deg, transparent 50%, var(--grey) 50%);
            /* box-shadow: 0 0 5px 5px blue; */
            /* outline: 2px solid yellow; */
        }
        /* width */
        ::-webkit-scrollbar {
            width: 0.5em;
        }

        /* Track */
        ::-webkit-scrollbar-track {
            background: transparent;
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: var(--grey);
            border-radius: 1em;
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text);
        }
        /* .radio input[type="radio"], .radio input[type="checkbox"], .radio select, .radio input[type="number"] { */
        .radio input, .radio select {
            margin: 0 0.5em;
        } 
        .radio input[type="radio"], .radio input[type="checkbox"] {
            width: 2em;
            height: 2em;
            transform-origin: left;
        }
        .radio input:first-child, select:first-child {
            margin: 0;
            margin-right: 0.5em;
        }
        .radio input:last-child, select:last-child {
            margin: 0;
            margin-left: 0.5em;
        }
        .radio {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-bottom: 0.5em;
        }
        .radio:last-child:not(.radio-nl) { /* nl: not last/new lines */
            margin-bottom: 0;
        }
        textarea {
            background-color: var(--back);
            color: var(--text);
            border: solid var(--grey) 0.5em;
            border-radius: 1em;
            padding: 0.5em;
            resize: vertical;
        }
        #textareainput {
            width: var(--textarea-size);
            height: 6em;
        }
        #theContainer {
            display: grid;
            grid-template-columns: 50% 50%;
        }
        #result textarea {
            width: var(--textarea-size);
            height: 30vh;
            overflow-y: visible;
        }
        .defaultHidden {
            display: none;
        }
        .defaultHidden[data-active] {
            display: inherit;
        }
        #version {
            position: fixed;
            top: 2em;
            right: 2em;
            font-size: small;
        }
        .alpha {
            color: #a00;
        }
        .beta {
            color: #aa0;
        }
        .experimental {
            color: #07f;
        }
    </style>
    <script>
        window.onload = function() {
            const lclsWarn = "option couldn't be loaded. They may not exist within localStorage."
            try {
                let whatmd = localStorage.getItem("mddcp-md");
                document.querySelector('input[name="marktab"]').checked = false;
                switch (whatmd) {
                    case "none":
                        document.getElementById("mark-none").checked = true;
                        break;
                    case "tab":
                        document.getElementById("mark-tab").checked = true;
                        break;
                    case "space":
                        document.getElementById("mark-space").checked = true;
                        break;
                
                    default:
                        break;
                    }
                markSpaceExtra();
            } catch(err) {
                console.warn("Markdown", lclsWarn);
                console.err(err);
            }
            try {
                let whatnr = localStorage.getItem("mddcp-nr");
                if (whatnr == '') {
                    whatnr = 4; /* set the default */
                }
                document.getElementById("mark-amount").value = Number(whatnr);
            } catch(err) {
                console.warn("Space Number", lclsWarn);
                console.err(err);
            }
            try {
                let whatmsg = localStorage.getItem("mddcp-2k");
                if (whatmsg === "") {
                    whatmsg = "disabled";
                }
                document.getElementById("splitmsg").value = whatmsg;
                splitMessagesExtra();
            } catch(err) {
                console.warn("Split Message", lclsWarn);
                console.error(err);
            }
            try {
                let whatlnb = localStorage.getItem("mddcp-ll");
                document.getElementById("splitmsg-ll").checked = JSON.parse(whatlnb);
                lastLinesExtra();
            } catch(err) {
                console.warn("Last Lines Checkbox", lclsWarn);
                console.error(err);
            }
            try {
                let whatlnbs = localStorage.getItem("mddcp-llstr");
                document.getElementById("splitmsg-llstr").value = whatlnbs;
            } catch(err) {
                console.warn("Last Lines String", lclsWarn);
                console.error(err);
            }
            try {
                let whatlnbs = localStorage.getItem("mddcp-cl");
                document.getElementById("charlimit").value = whatlnbs;
            } catch(err) {
                console.warn("Character Limit", lclsWarn);
                console.error(err);
            }
            try {
                let islmyes = localStorage.getItem("mddcp-lm");
                document.getElementById("lightmode").checked = JSON.parse(islmyes);
                lightmode();
            } catch(err) {
                console.warn("Light Mode", lclsWarn);
                console.error(err);
            }
        }
        let placeholderStillThere = true;
        function execute(elm) {
            const splitmsg = document.querySelector("#splitmsg").value;
            const marktab = document.querySelector('input[name="marktab"]:checked').value;
            let amount = undefined;
            const text = document.querySelector("textarea").value;
            if (marktab === "space") {
                let amount_elm = document.querySelector('#mark-amount').value;
                if (amount_elm === "") {
                    amount = 4; /* Set default if no value given */
                    return;
                }
                amount = Number(amount_elm);
            }
            /* Debugging */ console.log(splitmsg, marktab, amount, text);
            let regex = undefined;
            let spacesString = undefined;
            let replacestring = "  "; // The amount of spaces to replace it with
            let replacedtext = undefined;
            switch (marktab) {
                case "tab":
                    regex = new RegExp(`^(\t)*`, "gm");
                    spacesString = "\t";
                    break;
                case "space":
                    regex = new RegExp(`^(${" ".repeat(amount)})*`, "gm");
                    spacesString = " ".repeat(amount);
                    break;
            
                default:
                    break;
            }
            if (marktab !== "none") {
                replacedtext = text.replace(regex, function(match) {
                    return match.split(spacesString).join(replacestring);
                });
            } else {
                replacedtext = text; // some only want to split messages, how depressing...
            }
            let messages = [replacedtext];
            if (splitmsg == "smart") {
                messages = splitMessage2(replacedtext);
            } else if (splitmsg == "simple") {
                messages = splitMessage(replacedtext);
            }
            if (document.getElementById("textareainput").value !== "") {
                let oldAreas = document.querySelectorAll("#result textarea");
                oldAreas.forEach(element => {
                    element.remove();
                });
                for (let i = 0; i < messages.length; i++) {
                    const element = messages[i];
                    createResult(element, splitmsg);
                }
            }
            if (document.getElementById("textareainput").value === messages[0] && document.getElementById("textareainput").value !== "") {
                let oldAreas = document.querySelectorAll("#result textarea");
                oldAreas.forEach(element => {
                    element.remove();
                });
                let mockingTheUser = [
                    "this ain't a repeater",
                    "bro made something comparible to translating english to english",
                    "reall?",
                    "if (output === input) {mockUser();}",
                    "why",
                    "*mocks you*",
                    "*sames you*",
                    "To GeT tHe ReSuLt, ClIcK tHiS lInK!!!11!: https://www.youtube.com/watch?v=dQw4w9WgXcQ"
                ];
                let div = document.createElement("div");
                div.innerHTML = `<textarea data-no-result disabled style="text-align: center;color: var(--text); background-color: var(--back-red);">${mockingTheUser[Math.floor(Math.random() * mockingTheUser.length)] + " &#128128;"}</textarea>`;
                document.getElementById("result").appendChild(div.querySelector("textarea"));
            }
            console.log('"'+regex+'"', '"'+replacestring+'"');
        }
        function splitMessage(text) { /* legacy splitMessage + newly added customizable char_limit */
            let textarrs = [];
            let currentText = text;
            let char_limit = 2000;
            if (document.getElementById("charlimit").value !== "") {
                /* set custom character limit */
                char_limit = document.getElementById("charlimit").value;
            }
            for (let i = 0; i < Math.ceil(text.length/char_limit); i++) {
                textarrs.push(currentText.substring(0, char_limit))
                currentText = currentText.substring(char_limit);
            }
            return textarrs;
        };
        function splitMessage2(text) { // A more optimized approach
            // return: [array, with, all, splits]
            // returned by while(){} loop: ["output", "prepend to currentText"]
            let textarrs = [];
            let currentText = text;
            let char_limit = 2000;
            if (document.getElementById("charlimit").value !== "") {
                /* set custom character limit */
                char_limit = document.getElementById("charlimit").value;
            }
            let previousCurrentText = "";
            let keepEmptyLineString = "_ _";
            if (document.getElementById("splitmsg-llstr").value !== "") {
                /* custom force empty lines */
                keepEmptyLineString = document.getElementById("splitmsg-llstr").value;
            }
            const shouldKeepEmptyLine = document.getElementById("splitmsg-ll").checked;
            function nLineFix(substring, leftover) { /* only execute within while loop and after optimal slice was finished. */
                return [substring, leftover];
            }
            while (currentText !== "") {
                previousCurrentText = currentText;
                // apply 2k limit
                // split into char_limit_text and currentText
                let char_limit_text = currentText.substring(0, char_limit);
                currentText = currentText.substring(char_limit);
                // search for optimal position to cut instead of 2k.
                // lastOptimalSlice: The position of the most optimal to use substring against. NOTE: USE SUBSTRING, AS IT MAY RETURN -1.
                // usedSlice: string that contains the slice used.
                // noSlice: no slice is able to be used
                lastOptimalSlice = char_limit_text.lastIndexOf("\n");
                let usedSlice = "\n";
                let noSlice = false;
                if (lastOptimalSlice === -1) {
                    lastOptimalSlice = char_limit_text.lastIndexOf(" ");
                    usedSlice = " ";
                    if (lastOptimalSlice === -1) {
                        noSlice = true;
                    }
                }
                /* DEBUGGING */ console.log("SLICING METHOD:", JSON.stringify(usedSlice), "NoSlice:", noSlice);
                if (noSlice === true) {
                    textarrs.push(char_limit_text);
                } else if (currentText !== "") {
                    // slice the text
                    // substring: the first most optimized half
                    // leftover: the left over beteween substring and currentText
                    let substring = char_limit_text.substring(0, lastOptimalSlice);
                    let leftover = char_limit_text.substring(lastOptimalSlice + usedSlice.length);
                    // add keepEmptyLineString
                    console.log("Optimized Strings:", JSON.stringify(substring), JSON.stringify(leftover))
                    if (substring.endsWith("\n") && shouldKeepEmptyLine === true) {
                        /* DEBUGGING */ console.log("It ended with \\n!")
                        if (lastOptimalSlice < char_limit - keepEmptyLineString.length) {
                            /* if under limit */
                            substring += keepEmptyLineString;
                            /* DEBUGGING */ console.log("It's under the limit. keepEmptyLineString simply appended.")
                        } else if (lastOptimalSlice > char_limit - keepEmptyLineString.length) {
                            /* if inbetween limit and unaddable without going over the limit */
                            let counter = 0;
                            while (substring.endsWith("\n")) {
                                substring = substring.slice(0, -1);
                                counter++;
                            }
                            leftover = keepEmptyLineString + "\n".repeat(counter) + leftover;
                            /* DEBUGGING */ console.log("The Inbetween length was detected, keepEmptyLineString counter:", counter);
                        } else {
                            /* DEBUGGING */ console.log("...but nothing got executed.");
                        };
                    };
                    // re-add leftover to currentText and add substring to textarrs
                    currentText = leftover + currentText;
                    textarrs.push(substring);
                } else if (currentText === "") {
                    // add keepEmptyLineString
                    if (char_limit_text.endsWith("\n") && shouldKeepEmptyLine === true) {
                        char_limit_text += keepEmptyLineString;
                    }
                    // simply push it.
                    textarrs.push(char_limit_text);
                    console.log("Last currentText finished!");
                }
                // check if it was the same text again, if it wasn't you aren't fucked
                if (previousCurrentText === currentText) {
                    let aWarning = document.createElement("h3");
                    aWarning.innerText = `The Last Entry in the result may be over ${char_limit} characters long, as the last sliced and optimized text was the exact same as before. If we would've continued, your browser might've crashed!`;
                    aWarning.style.color = "#f00";
                    document.querySelector("#result h2").appendChild(aWarning);
                    break;
                }
                // debugging tools
                // console.log("THIS IS THE SUBSTRING\n\n"+ substring)
                // console.log("THIS IS THE LEFTOVER\n\n"+ leftover);
                // console.log("THIS IS EVERYTHING ELSE", lastOptimalSlice, usedSlice);
                // if (usedSlice===" ") {
                //     console.log("space slice used")
                // }
            }
            /* DEBUGGING */ console.log("FINAL ARGS", textarrs, JSON.stringify(currentText), char_limit, JSON.stringify(previousCurrentText), JSON.stringify(keepEmptyLineString));
            return textarrs;
        };
        function createResult(text, resize) {
            let area51 = document.createElement("textarea");
            area51.disabled = true;
            area51.value = text;
            document.getElementById("result").appendChild(area51);
            if (resize === false) {
                let newestChild = document.querySelector("#result *:last-child");
                newestChild.style.height = (newestChild.scrollHeight) + "px";
                newestChild.style.resize = "none";
            }
        }
        /* enable specific settings if certain things happen... */
        function markSpaceExtra() {
            let state = document.querySelector('input[name="marktab"]:checked').value;
            let div = document.getElementById("mark-space-extra");
            if (state == "space") {
                div.setAttribute("data-active", "");
                document.getElementById("mark-amount").setAttribute("required", ""); /* enforce them to say something, but also do not force them if it's not chosen */
            } else {
                try {
                    div.removeAttribute("data-active");
                } catch {}
                try {
                    document.getElementById("mark-amount").removeAttribute("required");
                } catch {}
            }
            console.log("mark-space-extra: State Changed to", state);
        }
        function splitMessagesExtra() {
            let state = document.getElementById("splitmsg").value;
            let div = document.getElementById("splitsmsg-extra");
            let div2 = document.getElementById("charlimit-parent");
            if (state == "smart") {
                div.setAttribute("data-active", "");
            } else {
                try {
                    div.removeAttribute("data-active");
                } catch {}
            }
            if (state == "disabled") {
                try {
                    div2.removeAttribute("data-active");
                } catch {}
            } else {
                div2.setAttribute("data-active", "");
            }
            console.log("split-messages-extra: State Changed to", state);
        }
        function lastLinesExtra() {
            let state = document.getElementById("splitmsg-ll").checked;
            let div = document.getElementById("splitmsg-llstr-parent");
            if (state === true) {
                div.setAttribute("data-active", "");
            } else {
                try {
                    div.removeAttribute("data-active");
                } catch {}
            }
            console.log("splitmsg-llstr-extra: State Changed to", state);
        }
        function lightmode() {
            let state = document.getElementById("lightmode").checked;
            if (state === true) {
                document.documentElement.style.setProperty('--text', '#000');
                document.documentElement.style.setProperty('--back', '#fff');
                document.documentElement.style.setProperty('--back-red', '#f22');
            } else {
                document.documentElement.style.setProperty('--text', '#fff');
                document.documentElement.style.setProperty('--back', '#000');
                document.documentElement.style.setProperty('--back-red', '#200');
            }
            console.log("lightmode: State Changed to", state);
        }
        function preventEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
            }
        }
        function fixNumUser(elm) {
            if (elm.value == "") {
                return;
            }
            if (elm.value != "" && elm.value < 1) {
                elm.value = 1;
            }
            elm.value = Math.floor(elm.value);
        }
        function resetSettings() {
            try {
                localStorage.removeItem("mddcp-md");
            } catch {}
            try {
                localStorage.removeItem("mddcp-nr");
            } catch {}
            try {
                localStorage.removeItem("mddcp-2k");
            } catch {}
            try {
                localStorage.removeItem("mddcp-ll");
            } catch {}
            try {
                localStorage.removeItem("mddcp-llstr");
            } catch {}
            try {
                localStorage.removeItem("mddcp-cl");
            } catch {}
            try {
                localStorage.removeItem("mddcp-lm");
            } catch {}
            localStorage.setItem("mddcp-rt", "");
            window.location.reload();
        }
        window.onbeforeunload = function() {
            if (typeof localStorage.getItem("mddcp-rt") === "string") {
                /* Reset Settings */
                console.log("Prevent saving of Settings due to reset!");
            } else {
                /* Save Settings */
                localStorage.setItem("mddcp-md", document.querySelector('input[name="marktab"]:checked').value);
                localStorage.setItem("mddcp-nr", document.getElementById("mark-amount").value);
                localStorage.setItem("mddcp-2k", document.getElementById("splitmsg").value);
                localStorage.setItem("mddcp-ll", document.getElementById("splitmsg-ll").checked);
                localStorage.setItem("mddcp-llstr", document.getElementById("splitmsg-llstr").value);
                localStorage.setItem("mddcp-cl", document.getElementById("charlimit").value);
                localStorage.setItem("mddcp-lm", document.getElementById("lightmode").checked);
            }
            try {
                /* Remove resetting again */
                localStorage.removeItem("mddcp-rt");
            } catch {}
        }
    </script>
</head>
<body>
    <h1>Discord Markdown Patch / Split Messages</h1>
    <div id="version">v1.0</div>
    <p>
        A very lightweight tool to fix discords markdown shitty Indention detection. Available for free on
        <a href="https://github.com/Lopolin-LP/markdown-discord-patch" target="_blank">GitHub</a>.
        <a href="https://raw.githubusercontent.com/Lopolin-LP/markdown-discord-patch/main/LICENSE" target="_blank">Licensed under GPLv3.</a>
    </p>
    <p>This tool is not very nice from a UI and user-kindness<sup>5</sup> stand point, so please be careful while using it.</p>
    <noscript style="color: red;">
        <h1><h1>You need JavaScript enabled for this website to work!</h1><br>Click <a href="https://www.enable-javascript.com/" target="_blank">HERE</a> to learn more.</h1>
    </noscript>
    <div id="theContainer">
        <form action="javascript:;" onsubmit="execute(this)">
            <!-- Markdown -->
            <div onclick="markSpaceExtra();"> <!-- why there no onchange for div? :( -->
                <h2>Markdown Indention Patch</h2>
                <div class="radio">
                    <input type="radio" id="mark-none" name="marktab" value="none">
                    <label for="mark-none">None</label>
                </div>
                <div class="radio">
                    <input type="radio" id="mark-tab" name="marktab" value="tab" checked="checked">
                    <label for="mark-tab">Fix Markdown (TAB)</label>
                </div>
                <div class="radio">
                    <input type="radio" id="mark-space" name="marktab" value="space">
                    <label for="mark-space">Fix Markdown (Space) <i>(Extra Options)</i></label>
                </div>
            </div>
            <!-- Extra Options -->
            <h2>Extra Options</h2>
            <div id="mark-space-extra" class="radio defaultHidden">
                <label for="mark-amount">Amount of Spaces per indent (Number)</label>
                <input type="number" name="mark-amount" id="mark-amount" min="1" value="4" placeholder="4" onkeyup="fixNumUser(this);">
            </div>
            <!-- Split Messages -->
            <div class="radio">
                <select id="splitmsg" onclick="splitMessagesExtra();">
                    <option value="disabled">Disabled</option>
                    <option value="simple">Simple</option>
                    <option value="smart">Smart (Recommended)</option>
                </select>
                <label for="splitmsg">Split Messages<sup>1</sup></label>
            </div>
            <div id="splitsmsg-extra" class="defaultHidden">
                <!-- Last Lines -->
                <div class="radio" onclick="lastLinesExtra();">
                    <input type="checkbox" class="radio-nl" name="splitmsg-ll" id="splitmsg-ll">
                    <label for="splitmsg-ll">Force Line Breaks at end of message to appear in Discord<sup>2</sup></label>
                </div>
                <!-- Last Lines: String -->
                <div class="radio radio-nl defaultHidden" id="splitmsg-llstr-parent">
                    <input type="text" name="splitmsg-llstr" id="splitmsg-llstr" placeholder="_ _">
                    <label for="splitmsg-llstr">Forced Line Breaks String<sup>3</sup></label>    
                </div>
            </div>
            <!-- Custom Character Limit -->
            <div id="charlimit-parent" class="defaultHidden">
                <div class="radio">
                    <input type="number" name="charlimit" id="charlimit" list="commonCharacterLimits" min="1" placeholder="2000" onkeyup="fixNumUser(this);">
                    <label for="charlimit">Charater Limit<sup>4</sup></label>    
                </div>
                <datalist id="commonCharacterLimits">
                    <option value="2000">Discord Free</option>
                    <option value="280">Twitter Free</option>
                    <option value="4000">Discord Nitro / Twitter Blue</option>
                </datalist>
            </div>
            <div class="radio" onclick="lightmode();">
                <input type="checkbox" class="radio-nl" name="lightmode" id="lightmode">
                <label for="lightmode">Light Mode</label>
            </div>
            <!-- Text Input -->
            <br>
            <h2>Text Input</h2>
            <textarea id="textareainput"></textarea>
            <!-- Submit -->
            <br>
            <h2>Submit and Other</h2>
            <input type="submit" value="Submit" id="submit-input" style="font-size: 2em;">
            <br><br>
            <input type="button" onclick="resetSettings();" value="Reset Options to Default (Reloads Webpage)" id="reset-input">
            <small>
                <br><br>
                <sup>1 </sup>Modes:<ul>
                    <li><b>Disabled:</b> No Split Messages</li>
                    <li><b>Simple:</b> Cuts everything EXACTLY after the character limit. Very Lightweight.</li>
                    <li><b>Smart (Recommended):</b> Tries to hide that these are multiple messages by cutting after line breaks, forcing new lines or cutting after a word. It's fully customizable. Only breaks when you really try to break it.</li>
                </ul>
                <sup>2 </sup>If an empty line is found at the very end of a message, it will force discord to make it appear<br>
                <sup>3 </sup>The String that gets appended to detected empty lines at end/beginning of messages is "_ _". With this you can change it. This string works because Discord cannot remove the whitespace at the end of message, because there is a "_", and Discord doesn't remove whitespace or empty lines inside messages.
                The reason for the other "_" is to make sure the other one disappears. It was chosen to use "_ _" over "** **" due to character amount, tho it doesn't matter in most cases.<br>
                <sup>4 </sup>After how many characters the message must be cut. A few presets are available. Create an issue on GitHub if you have suggestions.<br>
                <sup>5 </sup>If the Output is the EXACT same as the input, you will get mocked. <!-- Would be funny if you get mocked there is an option to permanently disable it. When you reset all settings it gets changed back as well -->
            </small>
        </form>
        <div id="result">
            <h2>Result</h2>
            <textarea data-no-result disabled style="text-align: center;color: var(--text); background-color: var(--back-red);">There is not Result yet!</textarea>
        </div>
    </div>
    <br><br>
    <script>
        allInputs = document.querySelectorAll("input");
        for (let i = 0; i < allInputs.length; i++) {
            const element = allInputs[i];
            element.addEventListener("keypress", ()=>{preventEnter(event)});
        }
        enterEventSpecial = {
            splitmsg: document.getElementById("splitmsg"),
            submit: document.getElementById("submit-input")
        }
        enterEventSpecial.splitmsg.removeEventListener("keypress", ()=>{preventEnter(event)});
        enterEventSpecial.splitmsg.addEventListener("keypress", function (event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                this.checked = !this.checked;
            }
        });
        enterEventSpecial.submit.removeEventListener("keypress", ()=>{preventEnter(event)});
        enterEventSpecial.submit.addEventListener("keypress", function (event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                enterEventSpecial.submit.click();
            }
        });
    </script>
</body>
</html>
